
\subsection*{Kernel space}

В ядре существует три <<множества>> памяти:
\begin{enumerate}
\item Начало виртуальной памяти
\item Область DMA
\item Прочее
\end{enumerate}

\subsubsection*{Buddy-алгоритм и slab-алгоритм}
\verb!buddy-алгоритм! стремится минимизировать количество <<дырок>> в ОП.

Память поделена на куски размера $2^n$. Далее выделение памяти M байт происходит так:
\begin{enumerate}
\item Часть делится пополам, пока она не станет минимального размера, который все еще не меньше M байт.
\item M байт записываются в соответствующую ячейку.
\item При освобождении данной ячейки она объединяется с соседней в одну ячейку большего размера.
\end{enumerate}

\verb!slab! характеризуется размером и типом объекта. Когда \verb!slab! нужно расширить, то запускается \verb!buddy-алгоритм!.

\subsection*{Работа с памятью на уровне процесса}

Существует несколько функций для работы с памятью:
\begin{itemize}
\item malloc --- вызывает функцию по работе с кучей. Если в куче недостаточно места для выделения данного объема памяти, то происходит системный вызов \verb!brk(size)! --- он увеличивает сегмент данных на \verb!size!. \verb!dcmalloc! --- алгоритм реализации \verb!malloc!'а. Более высокоуровневые реализации: \verb!tcmalloc, jemalloc!.
\item calloc --- то же самое, что \verb!malloc!, только отображает виртуальную память на таблицу страниц, которая отображается на \verb!read only! страницу в ОП из нулей. Если произошла запись, то данный диапазон адресов уже не отображается на страницу из нулей, а создается новое отображение на другую часть ОП.
\item realloc --- манипулирует с таблицей страниц виртуальной памяти. При вызове данной функции происходит копирование таблицы страниц, то есть наблюдалась такая ситуация: диапазоны адресов отображаются через таблицу страниц на ОП, нужно добавить еще кусок к данному диапазону, но этот кусок перекрывается с другим, таким образом, нужно перезаписать таблицу страниц и добавить к ней нужный кусок (ведь мы хотели получить непрерывный кусок памяти).
\item free --- освобождает память.
\end{itemize}

\subsection*{Виртуальная файловая система}

Виртуальная файловая система имеет иерархическую структуру.

С ней можно выполнять операции монтирования и размонтирования.

Монтирование --- момент, когда ядро использует тройку <драйвер устройства, драйвер файловой системы, точка монтирования>, чтобы создать связку между файловой системой, файлом устройства и точкой монтирования.

\subsubsection*{Типы объектов файловой системы}
\begin{enumerate}
\item Файл
\item Каталог
\item Файл устройства

\verb!/proc! и \verb!/sys! состоят полностью из файлов устройств
\item Символическая ссылка --- некоторый файл, в котором прописан путь до данного файла
\item PF\_UNIX (для socket())
\item FIFO (для mkfifo()) --- то же самое, что и \verb!pipe!, только с именем
\end{enumerate}

Обобщенный индексный дескриптор --- представление типа объекта файловой системы. Этот дескриптор должен существовать для любого объекта в файловой системе.
\\

Что же записано в дескрипторе:
\begin{enumerate}
\item Тип
\item Права доступа: u(rwx), g(rwx), o(rwx), suid bit, t bit, acl (access control list) --- ассоциирует шаблон пользователя (группы) с группой (пользователем)
\item Владелец --- uid
\item Группа --- gid
\item Даты чтения и модификации
\item Файл устройства
\item Ссылка на данные устройства, где расположен физический индексный дескриптор
\end{enumerate}

Системный вызов \verb!stat! возвращает обобщенный  индексный дескриптор.

Каталог с именем <<..>> --- ссылка на каталог выше по иерархии, с именем <<.>> --- ссылка на текущий каталог.
\\

В каталоге хранится:
\begin{enumerate}
\item Имя файла
\item Ссылка на индексный дескриптор
\item Тип файла
\end{enumerate}

Список системных вызовов для \underline{еще не открытого} файла:
\begin{itemize}
\item stat --- возвращает индексный дескриптор
\item open --- открывает файл
\item link --- создает символическую ссылку
\item unlink --- удаляет символическую ссылку
\item mmap --- отображает файлы в ОП
\end{itemize}

Список системных вызовов для \underline{открытого} файла:
\begin{itemize}
\item close --- закрывает файл
\item read --- читает из файла
\item write --- записывает в файл
\item fstat
\item lseek
\end{itemize}

\subsection*{Файлы устройств}

Для файлов устройств в индексном устройстве также записаны:
\begin{itemize}
\item Мажорный номер --- определяет шину, на которой записано устройство
\item Минорный номер --- номер устройства на шине
\end{itemize}

Для регистрации устройств используется программа \verb!udev!(раньше --- скрипт MAKEDEV). Просматривает \verb!/sys/bus! и, если были какие-то изменения, создает файлы устройств.

Например, при подключении USB-устройства ядро подгружает драйвер устройства, далее создаются указатели на реализации функций для работы  с файлом устройства как объектом файловой системы. Ссылка на вектор с реализациями функций лежит в таблице с минорными номерами.