\subsection{Жизненный цикл процесса}
\begin{enumerate}
\item Создание процесса. Процесс создаётся обычно при помощи \verb!fork()!, но на самом деле созданием процессов можно управлять на более тонком уровне при помощи системного вызова \verb!clone(...)!, а \verb!fork! является неким макросом над ним.
\item Попадание в очередь готовых к выполнению. В этой очереди все процессы сортируются согласно приоритету. У приоритета есть статическая и динамическая составляющие. Динамическая задаётся ядром, статическая --- частично ядром, частично пользователем.
\item Ядро выбирает процесс с наименьшим значеним приоритета и назначает его на выполнение.

 Из состояния выполнения можно вернуться в очередь готовых к выполнению, а можно перейти в одну из следующих стадий
\begin{itemize}
\item Стадия <<зомби>>. В этом состоянии процесс выполняться не будет, тело процесса не существует, но есть информация о том, как завершился процесс и всё ещё занята строчка в таблице процессов.

После этого процесс может перейти в состояние полного завершения
\item Состояние остановки (по получению сигнала). 

Отсюда можно попасть в очередь готовых к выполнению, а оттуда можно перейти как к выполнению, так и в состояние зомби и даже обратно в состояние остановки. В состояние зомби из очереди готовых к выполнению процесс может перейти при получении \verb!SIGKILL! от ядра

\item Ввод-вывод. В это время работа процесса приостановлена, но он считается активным. Самостоятельно (без использования \verb!read! и \verb!write!) перейти в эту стадию процесс может только при своппинге, если нужная область памяти выкачена на внешний диск. 

После этого можно перейти либо в очередь готовых к выполнению, либо в состояние <<зомби>>
\end{itemize}
\end{enumerate}

\subsection{Создание процесса}

Процесс создаётся при помощи системного вызова \verb!clone(...)! или же макроса над ним --- \verb!fork()!. Они возвращают \verb!pid_t! --- pid порождённого процесса. \verb!fork! создаёт новый процесс, который является копией родителя.

При создании процесса \textbf{не копируются}:
\begin{itemize}
\item Вектор и очередь сигналов
\item \verb!pid!, \verb!ppid!
\end{itemize}

Вся остальная информация копируется, в том числе и открытые файлы. При этом курсор в этих файлах будет общий, т.е. при сдвиге курсора в одном из процессов, курсор в другом процессе также сдвинется. Но при открытии новых файлов, они будут независимы.

Процесс состоит из
\begin{itemize}
\item Инструкций
\item Информации
\item Стека процесса
\end{itemize}

При использовании \verb!fork! инструкции не меняются, а информация в памяти вместе со стеком копируется. Если копировать всю информацию сразу, то это будет долго. Для этого используется ленивое копирование.

При ленивом копировании страницы виртуальной памяти копируются и помечаются read-only. Пока происходят только запросы на чтение, всё нормально. Как только происходит запрос на запись, операционная система получает page fault и выделяет новому процессу память, модифицируя таблицу страниц, снимая флаг read-only у родительского процесса.

\verb!vfork! не запускает ленивое копирования, а просто блокирует родительский процесс до момента смены тела нового процесса.

\subsection{Смена тела процесса}

\begin{itemize}
\item Мягкий способ --- \verb!mmap!. Берётся некий бинарный файл и отображаем его на определённые адреса в виртуальной памяти.
\item Тоже мягкий способ --- динамически подгружаемые библиотеки --- \verb!dlopen! --- расширяет сегмент кода и интерпретирует часть файла как код, добавляя его в сегмент кода.
\item Жёсткий способ --- \verb!execve!.
\begin{verbatim}
int execve(const char *filename, char *const argv[], char *const envp[]);
\end{verbatim}
При данном способе смены тела процесса сегмент кода полностью заменяется на содержимое файла.
\end{itemize}

Переменная окружения --- строка вида \verb!<имя переменной>=<значение>!

Библиотека \verb!libc! предоставляет различные надстройки над \verb!execve! вида \verb!exelp!, \verb!execle! и другие.

\subsection{Об <<отцовстве>> процессов}

В системе существует некоторая древовидная иерархия процессов с корнем в процессе 1 (init). Имеется две сущности: идентификатор сессии \verb!sesid!, который создаётся при входе в систему. Сразу при входе в систему создаётся процесс, который является лидером сессии. Обычно это shell, но, в целом, это может быть любая другая программа.

У всех процессов, которые наследуются от лидера сессии, один и тот же \verb!sesid!.

Примерно также имеется идентификатор группы \verb!gid!. Сменить идентификатор сессии можно только на свой \verb!pid!, тогда как идентификатор группы ещё и на \verb!pid! отца.

А что делать, если процесс осиротел? В этом случае его отцом становится init, который его \verb!wait!'ает.

Если же процесс умер, но у него остались потомки, то init начинает их истреблять. Сначала он делает это вежливо (\verb!SIGTERM!), а потом грубо (\verb!SIGKILL!).

\subsection{Переключение процессов}

\subsubsection{Режимы переключения}

В случае, когда процессов много, а ядер мало, нужно уметь переключаться между процессами. Для этого есть несколько решений:
\begin{itemize}
\item Пакетный режим. В этом режиме процессу выставляется предельное время исполнения, по истечении которого процесс принудительно завершается. 

Такая система хороша в случае, когда переключение между процессами слишком дорогостоящая операция (например, при больших вычислениях на кластерах).

\item Режим разделения времени. Каждому процессу выделяется некий квант времени. Операционная система по прерываниям таймера смотрит в очередь готовых на выполнение и при наличии процесса с меньшим приоритетом инициализирует новый процесс, <<откладывая>> старый в очередь на готовых к выполнению.

\item Режим реального времени. В этом режиме на каждую операцию устанавливается так называемый директивный интервал. В общем случае это интервал, в который операция должна выполниться. При этом должна быть гарантия, что операция успеет выполниться за данный интервал. В таких системах у процессов нет приоритетов как таковых,  а всё планируется заранее и переключение происходит по границам директивных интервалов.

У директивного интервала может не быть правой границы, но левая должна быть всегда.
\end{itemize}







\subsubsection{Механизм переключения}

При переключении ядро должно сделать следующее:
\begin{enumerate}
\item Сохранить состояние регистров
\item Подгрузить таблицу страниц нового процесса в оперативную память
\item Модифицируем таблицы процессов, меняем \verb!pid! активного процесса
\item Понижение прав и переход на отложенный адрес в другом процессе
\end{enumerate}











