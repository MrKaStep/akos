\subsubsection{Типы даннах в архитектуре}

\begin{itemize}
\item Адреса
\item Целочисленные типы. В скобках указаны суффиксы, которые дописываются к командам, чтобы понимать, какой длины аргумент используется.
\begin{itemize}
\item 1 byte --- байт (b), \verb!char! в C
\item 2 bytes --- слово (w), \verb!short! в C
\item 4 bytes --- удвоенное слово (d), \verb!int! в C
\item 8 bytes --- учетверённое слово (q), \verb!long int! в C
\item 16 bytes --- 128 bit (o), \verb!long long int! в C
\end{itemize}
Для хранения отрицательных чисел используется так называемый дополнительный код. Для получения числа $-A$ мы вычитаем из него 1 и инвертируем все биты.
\item Типы с плаваюзей точкой. 
\begin{itemize}
\item \verb!float! (d)
\item \verb!double! (q)
\item \verb!long double! (o)
\end{itemize}
Для представления этих типов используется запись вида \linebreak<знаковый бит>:<знаковый бит экспоненты>:<7/10 бит экспоненты>:<мантисса>. Мантисса при этом хранится не в дополнительном а в прямом коде. То есть у чисел с плавающей точкой есть +0 и -0. Всякие случаи вида хранения нуля, $\pm\infty$ описаны в стандарте IEEE 754. 0 хранится всеми нулями. \verb!NaN! хранится как все единицы. $\infty$ хранится как знак бесконечности в знаке, все единицы в порядке и все нули в мантиссе.
\item Строки. Непрерывныя последовательность байт, которую можно целиком перенести в другую область памяти.
\item Биты. Их можно хранить двумя разными способами. Можно считать, что младшие биты хранятся на младших адресах, а можно наоборот. То есть число можно читать "слева направо" и "справо налево" в порядке увеличения адресов.
\begin{itemize}
\item Little-endian --- старшие биты хранятся в байтах со старшими адресами
\item Big-endian --- старшие биты хранятся в байтах с младшими адресами
\end{itemize}
\end{itemize}
\subsubsection{Виды регистров}

\begin{itemize}
\item РОН (регистры общего назначения) --- могут использоваться командами
\item Служебные регистры --- на них лежит управление работой процессора
\begin{itemize}
\item IP --- instruction pointer. Read-only регистр. Может называться IP (16bit), EIP (Extended IP, 32bit), RIP (Rich IP, 64bit)
\item Регистры флагов (FLAGS, EFLAGS, RFLAGS) --- некоторые флаги после выполнения команды. Например, после переполнения при сложении будет выставлен флаг переполнения. 
\begin{itemize}
\item DF (Direction Flag), который задаёт направление операции, операции перемещения строки или побитового сдвига.
\item ZF (Zero Flag), обычно используется в счётчиках цикла, выставляется, если последняя операция дала 0. Для этого в ассемблере используется JE, которая проверяет ZF и, если он установлен в 1, то переходит по указанной метке
\item Бит чётности
\item Бит переноса
\item И другие
\end{itemize}
\end{itemize}
\end{itemize}

%TODO Расставить VERB

\subsubsection{Виды команд}
\begin{itemize}
\item Побитовые:
\begin{itemize}
\item XOR
\item AND
\item OR
\item ROL (специфична для Intel) --- циклический сдвиг
\item SHL, SHR --- битовый сдвиг влево и вправо соответственно.
\end{itemize}
\item Арифметические:
\begin{itemize}
\item MUL --- умножение
\item DIV --- деление
\item ADD --- сложение
\item SUB --- вычитание
\item MOD --- остаток по модулю
\end{itemize}
Для всех этих операций есть I-версия
\item Перемещение память-регистр:
\begin{itemize}
\item MOV
\item CMP операция сравнения, выставляет флаги
\item Команды расширения: CBW (b $\to$ w) и другие. Добавление суффикса E к команде означает сохранение знака. Сокращение же производится автоматически при перемещении из большего типа данных в меньший банальным <<отрубанием>> всего лишнего.
\end{itemize}
\item Операции переходов:
\begin{itemize}
\item JMP --- переход на указанный адрес. Если у нас память слишком большая, а разрядность, например, 32 бита, то для длинного прыжка нужно использовать farjmp, то есть изменить область view, после чего сделать JMP.
\item JE --- условный переход при флаге равенства нуля
\item JG --- условный переход при флаге больше нуля
\item JL --- условный переход при флаге меньше нуля
\item JGE --- условный переход при флаге больше или равно нуля
\item JLE --- условный переход при флаге меньше или равно нуля
\item Частным случаем перехода является функция CALL, которая вызывает функцию при помощи стека. Им управляют 2 регистра общего назначения SP и BP. Регистр SP (Stack Pointer) указывает на вершину стека. Перед вызовом процедуры аргументы нужно положить в стек в каком-то порядке, перемещаем SP на вершину. BP указывает на начало <<стопки аргументов>>. После выделяется память в стеке для выполнения процедуры. ENTER перемещает SP на столько, на сколько нужно для выделения памяти для процедуры. LEAVE возвращает SP на место.

Функция CALL проделывает все вышеуказанные действия и переходит на начало функции. RET же, производит обратное действие
\end{itemize}
\item Работа со стеком:
\begin{itemize}
\item PUSH
\item POP
\item PUSHA --- добавить все регистры общего назначения в стек
\item POPA --- убрать все регистры общего назначения из стека%
\end{itemize}
\end{itemize}

