\subsection{Соглашение о передаче параметров}

Пусть есть абстрактный язык программирования ProgL.
Как передавать параметры функции, написанной на этом языке?
\begin{enumerate}
\item Можно класть параметры в стек. А в каком порядке? Пусть наша функция имеет вид \\\verb!func(a, b, c, d)!.
\begin{enumerate}
\item порядок push для аргументов.
\begin{itemize}
\item Можно класть аргументы в стек в том порядке, в котором они идут в вызове функции (снизу вверх). 

\item Можно наоборот, сверху вниз, в обратном порядке поступления аргументов. В этом случае на вершине стека будет лежать первый аргумент (как в C)

\end{itemize}
\item порядок очищения стека.
\begin{itemize}
\item вызывающий очищает стек (как в C)
\item вызываемый очищает стек
\end{itemize}
\end{enumerate}
\item Для передачи параметров можно использовать \textit{регистры общего назначения}. В архитектуре Intel таких регистров 16. В языке C можно передавать \verb!char, short, int, long, long long!. С типом \verb!long long! возникает проблема: он не помещается в один регистр. Для этого используются {\small$\left[\begin{gathered}
\verb!rax!\\
\verb!rbx!\\
\end{gathered}\right.$}. Таким образом, у нас становится на два регистра меньше. Всё, что не поместилось в регистры, помещается на стек, как в п.1.
\item Возвращаемое значение
\begin{itemize}
\item на вершину стека
\item на регистры (как в C)
\end{itemize}
\end{enumerate}

\subsection{Позиционно зависимый/независимый код}

Когда может быть нужен позиционно независимый код (который может быть размещён по любому адресу в виртуальной памяти и он будет исполняться нормально)? \textbf{Почти всегда}.

А как добиться позиционной независимости?

\begin{enumerate}
\item Избегать прямой адресации.

В архитектуре amd64 есть возможность чтения регистра \verb!rip!, который содержит адрес следующей выполняемой инструкции. На его основе построен метод относительной адресации RIP-relative.

%TODO

\item Также, в случае подключения библиотеки в процессе выполнения программы, вызов библиотечной функции должен осуществляться не по обычному адресу, а по адресу перехода из таблицы символов. Если мы знаем, что функция будет лежать третьей в таблице символов, то код будет выглядеть так:
\begin{verbatim}
mov T, %rdi
call 3(%rdi)
\end{verbatim}

В случае отстутствия нормальной функции, будет осуществлён переход на функцию-заглушку или произведена динамическая линковка, которая заключается в проходе по таблице символов и поиске нужных функций в файловой системе в библиотеках, указанных при компиляции с ключом \verb!-l!.
\end{enumerate}

А когда может пригодиться позиционно \textbf{зависимый} код?

\begin{enumerate}
\item Загрузчик ОС
\item Сама операционная система, а именно, ядро в привилегированном режиме. В частности, для драйверов устройств
\end{enumerate}

\subsection{Таблица сегментов}

В таблице сегментов описание сегментов содержит
\begin{enumerate}
\item бит представленности (1, если этот сегмент можно использовать)
\item база --- начало сегмента в оперативной памяти
\item размер сегмента в у.е.
\item размер у.е., а точнее, номер этого размера Не может быть произвольным, есть заранее определённый набор возможных значений.
\item тип
\item права доступа
\item уровень привилегий
\end{enumerate}

\subsection{Страничная организация памяти}

Страничная организация памяти может существовать независимо от сегментной.

Виртуальная память делится на некоторые диапазоны страниц. Минимальный размер каждого диапазона --- одна страница.

Информация о страницах хранится в таблице страниц.

Каждый адрес разбивается на части:
\begin{enumerate}
\item Информация о записи в каталоге страниц 0 уровня
\item Информация о записи в каталоге страниц 1 уровня
\item \ldots
\item номер страницы
\item смещение внутри страницы
\end{enumerate}

Для получения значения в адресе производится просмотр соответствующего диапазона в каталоге 0-го уровня. Если диапазон используется, то происходит переход в каталог страниц 1-го уровня и такой-же опрос диапазона адресов, но диапазон уже меньше. Если диапазон оказался неиспользуемым, то создаётся ошибка page fault.

Такой спуск продолжается до тех пор, пока не будет найдена нужная страница или не произойдёт page fault.

Для ускорения этого поиска используется TLB-кэш. В нём хранится старшая часть виртуального адреса и соответствующий ей адрес в оперативной памяти. Поиск в первую очередь производится по этому кэшу и только потом --- по иерархии каталогов.

В каждой записи каталога/таблицы страниц хранится следующая информация:
\begin{enumerate}
\item бит представленности
\item <<бит грязности>> --- были ли операции записи. В дальнейшем используется для своппинга
\item бит доступа
\item права
\item уровень привилегий
\item (если каталог) размер страницы
\item адрес в оперативной памяти
\end{enumerate}

Чем же плоха такая структура? Она плоха тем, что при одном обращении к адресу, происходит негарантированное количество реальных обращений к каталогам страниц. Также тратится много оперативной памяти на хранение самой структуры каталогов