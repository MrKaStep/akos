\subsubsection{Квант времени планирования процессов}

$\Delta t$ --- квант времени планирования. Это непрерывный интервал, внутри которого переключение процессов не допускается. Это параметр ядра, то есть устанавливается при его компиляции.

Можно сделать
\begin{enumerate}
\item Маленький промежуток
\begin{itemize}
\item Отзывчивость системы. Помогает на ноутбуках и телефонах. Например, процесс, отлавливающий нажатие элемента на экране, довольно быстро среагирует на нажатие. Это называется \textbf{io-intensive} --- интенсивный ввод-вывод.
\end{itemize}
\item Средний промежуток --- некоторый компромисс между большим и малым промежутком.
\item Большой промежуток. Если сделать интервал слишком большим, то получится пакетный режим, поэтому такой промежуток всё же исчисляется микросекундами. 
\begin{itemize}
\item Помогает для больших вычислений. Тратится мало времени на переключение процессов, процесс может долго заниматься одним вычислением, не теряя при этом кеш-память.

То есть помогает для серверного режима и для трудоёмких вычислений.
\end{itemize}
\end{enumerate}

\subsubsection{Приоритеты}

Приоритет процесса состоит из
\begin{itemize}
\item Динамической составляющей
\begin{itemize}
\item  Динамический приоритет, понижающийся со временем нахождения в очереди. Если процесс недавно выполнялся, то эта составляющая устанавливается большой и понижается со временем.

При \verb!fork!'е, у порождённых процессов выставляется маленькая динамическая составляющая, поэтому при завершении кванта времени будут сначала выполнены именно они, а затем, после уравнивания приоритетов, отцовский процесс.
\end{itemize}
\item Статической составляющей
\begin{itemize}
\item Приоритет пользователя (у пользователя 0 приоритет должен быть немного выше, чем у обычных пользователей)
\item Приоритет, назначаемый пользователем
\item Число, добавляемое ядром, чтобы приоритет пользовательских процессов был больше, чем у внутренних процессов ядра
\end{itemize}
\end{itemize}

\subsubsection{Процессы реального времени в системах с разделением времени}

Это процессы, при возникновении которых все остальные процессы будут остановлены. Его нельзя прерывать никаким процессам, кроме процессов ядра. 

Пример необходимости такого процесса --- запись на CD-ROM. Если диск будет раскручен, лазер зажжён, а данный перестанут поступать из-за переключения процесса, то болванка будет испорчена.

\section{Потоки (threads)}

Потоки --- это некоторая идеология. В этой идеологии внутри процесса создаются так называемые <<нити>>, которые исполняются в этих самых потоках, но не являются независимыми процессами, а являются лишь частью процесса. Это поток команд, который выполняется в адресном пространстве процесса. На практике, в системе Linux это почти обычные процессы, созданные, например, операцией \verb!clone! со специальными параметрами.

Количество этих нитей обычно совпадает с количеством ядер в машине (например, на 4-ядерном процессоре без Hyoer-Threading'а делают 4 <<нити>>). В Linux количество нитей ограничено количеством процессов, которые можно порождать.

Для создания <<нитей>> можно использовать встроенные интерфейсы, параметры компилятора (\verb!#pragma ...!) а также библиотечную функцию \verb!pthread_create!. Функция, с которой создаётся процесс, должна возвращать \verb!void*!, обычно возвращает \verb!NULL!, а результат выполнения получают через глобальные переменные

У нити и исходного процесса
\begin{itemize}
\item Сегменты данных \textbf{идентичны}, при изменении переменной в одной нити, она меняется везде
\item Сегменты кода \textbf{идентичны}, как и при \verb!fork!
\item Стеки \textbf{разные}. При создании новой <<нити>> создаётся новый стек. На вершину стека кладётся указатель на функцию, которая используется для создания потока.
\end{itemize}

Это почти то же самое, что и при \verb!exec!'е, за исключением того, что происходит переключение на на динамический линковщик, а сразу на реализацию функции.

\subsection{Потоки в POSIX}

Для использования потоков есть библиотека \verb!<pthread.h>!. Использование выглядит примерно так:
\begin{verbatim}
pthread_t thread;
pthread_create(pthread_t *thread, attr, body, void* args);
\end{verbatim}

В аргументах передаётся указатель на переменную потока, адрес функции и аргументы, с которыми будет вызвана функция. После порождения потока и его завершения, нужна синхронизация. Для этого используется \verb!pthread_join(thread, void*)!, которая дождётся завершения завершения потока и по второму аргументу получит результат выполнения функции.

\textit{Я тебя породил, я тебя и убью}.

Поток можно уничтожить при помощи \verb!pthread_cancel(thread)!. 

Поток может и сам завершиться досрочно при помощи \verb!pthread_exit(void*)!.

Поток можно отсоединить от родительского процесса при помощи \verb!pthread_detach(thread)!.

\section{Сигналы}

\subsection{Реакция на сигналы}

\begin{enumerate}
\item Игнорирование. В этом случае он возникает и... убивается операционной системой. Происходит ничего
\item Завершение без дампа памяти. Выполняется операционной системы
\item Завершение с дампом памяти
\item Остановка процесса
\item Продолжение работы
\item Вызов пользовательской функции-обработчика
\end{enumerate}

Есть два <<неприличных>> сигнала:

\begin{itemize}
\item \verb!SIGSTOP! --- принудительная остановка процесса. В режиме остановки он может быть убит только при помощи \verb!SIGKILL!, но за одним исключением. Если процесс находится в режиме ввода-вывода и ядро не может гарантировать согласованность завершения с точки зрения оперативной памяти
\item \verb!SIGKILL! --- принудительное завершение процесса.
\end{itemize}


\subsection{Сигнальная маска}

Обычные сигналы можно маскировать. Маска сигналов (или вектор сигналов), является числом-битовой маской и принадлежит ядру.

Передача сигнала процессу происходит при переключении на этот процесс, кроме сигналов \verb!SIGSTOP! и \verb!SIGKILL!, так как при обоих этих сигналах нет смысла передавать управление процессу.

Для порождаемых потоков маска сигналов установлена в маскирование всех сигналов, сигнал передаётся в основной поток. Сигналы обрабатываются только им.

\subsection{Сигналы реального времени}

Сигналы реального времени складываются в очередь. Номера этих сигналов расположены между \verb!SIGRTMIN! и \verb!SIGRTMAX! включительно. Обработка сигналов происходит в порядке их появления в очереди.

\subsection{Обработчики сигналов}

Обработчикам сигналов разрешается пользоваться только системными вызовами или более высокоуровневыми объектами, которые не используются в основной программе. Корректность работы гарантируется только для системных вызовов.

При наличии функции-обработчика, при передаче управления процессу, вызывается этот самый обработчик и этот сигнал маскируется.

\begin{itemize}
\item Старый интерфейс
\begin{verbatim}
void handler(int)
\end{verbatim}
\item Новый интерфейс
\begin{verbatim}
void handler(int, sig_info_t, void*...)
\end{verbatim}
\end{itemize}

При этом функция-обработчик выполняется в собственном стеке. По завершении функции-обработчика ядро размаскирует сигнал и передаёт управление обратно в функцию.

Не исключено, что до завершения обработчика придёт другой сигнал. В этом случае будет вызван следующий обработчик









