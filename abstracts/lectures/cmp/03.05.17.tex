\section{Виртуальные машины (уровень виртуализации)}

Виртуализация --- создание видимости того, что исполняемый код выполняется на нескольких машинах, при том, что на самом деле всё происходит на одном и том же железе.

\subsection{Уровни виртуализации}

\begin{enumerate}
\item Аппаратная виртуализация. Обычно используется для разделения аппаратных ресурсов между запускаемыми операционными системами. Например, при запуске нескольких ОС оперативная память может быть поделена на куски и каждой запущенной ОС будет выдан некоторый диапазон адресов, создана <<иллюзия>> наличия только выданного куска оперативной памяти.
\item Виртуализация с hypervisor. Задача hypervisor'а --- распределение запросов к ресурсам машины от ядер запускаемых ОС. Ядра при этом модифицируются для возможности общения с hypervisor'ом.

Сам  hypervisor --- тоже в некотором смысле ОС, но урезанная --- без управления процессами, без файловой системы и т.д.

После запуска загрузчик первым делом запускает hypervisor.

Такие виртуальные машины работают несколько медленнее, чем с аппаратной виртуализацией, за счёт наличия прослойки hypervisor'а, потребляющей некоторые ресурсы

\item Виртуальная машина в user mode. В этом случае виртуальные машины запускаются как пользовательские процессы в основной ОС.

При таком подходе все экземпляры виртуальных ОС могут получить доступ ко всем физическим ресурсам машины одновременно. Также при такой виртуализации на виртуальных машинах доступен тот же набор инструкций, что и на основной машине

\item Полная эмуляция другой архитектуры. В этом случае скорость уже не важна, но важна полнота эмуляции, используется в основном разработчиками этих самых архитектур.

\end{enumerate}

\section{Управление оперативной памятью ядром}

Для поддержки отображения страниц на физические адреса в ядре есть <<таблица>> для управления физической памятью. В этой таблице хранится список диапазонов. Внутри каждого диапазона может быть множество объектов, привязанных к этому диапазону. Объектом, например, может быть 

\begin{itemize}
\item Операция ввода-вывода, зарегистрированная пользователем
\item память, выделенная пользовательскому процессу (тогда в объекте будет храниться ссылка на контекст процесса) и другое.
\end{itemize}

C каждым диапазоном связана величина \verb!lru! (last recently used). Это два числа --- \verb!r! и \verb!w! --- последнее чтение и последняя запись. Эти величины хранятся в некоторой внутренней системе отсчёта времени, например, в количестве тактов.

\subsection{Swapping}

Swap --- это некоторый диапазон на внешнем запоминающем устройстве, в котором содержатся несколько диапазонов адресов ОП. Используется в случае, когда место в оперативной памяти начинает заканчиваться.

Диапазоны бывают двух типов:

\begin{enumerate}
\item Чистый --- когда в оперативной памяти и на внешнем устройстве хранится идентичная информация.
\item Грязный --- когда информация в оперативной памяти не синхронизированна с внешним устройством.
\end{enumerate}

\subsubsection*{Страничный демон}

Страничный демон --- процесс, просыпающийся по внутреннему таймеру ядра. Он инициирует процессы записи на внешнее устройство после операции записи в оперативную память, освобождая таким образом набор диапазонов в оперативной памяти.

Есть несколько алгоритма, по которым выбираются диапазоны для выгрузки в swap: 
\begin{itemize}
\item LRU (Last Recently Used) --- выгрузка последнего использованного диапазона
\item NRU (Not Recently Used). Собирает некоторую статистику и выбрасывает наименее использованный диапазон
\item <<Алгоритм часов>> --- учитывает и частоту чтения, и частоту записи, и выбрасывает (при прочих равных) то, что было реже прочитано.
\end{itemize}

\subsection{Что делать, если кончилась память?}

\verb!vm.overcommit_memory! и \verb!vm.overcommit_ratio! --- величины, которые можно менять в \linebreak \verb!/etc/sysctl.conf!. В \verb!vm.overcommit_memory! можно записать три значения

\begin{itemize}
\item 0 --- ядро не выпадет в Kernel Panic и будет позволять программам выделять памяти больше, чем физической. Будет происходить ленивое выделение памяти. Но когда память кончится включится добрый OOM Killer. 

При помощи некоторых эвристических алгоритмов будет выбран процесс с ненулевым эффективным идентификатором пользователя и наибольшим использованием памяти... и будет убит.

\item 1 --- Ядро выпадает в Kernel Panic

\item 2 --- Считается величина $swap + mem \cdot \frac{ratio}{100}$, которая является допустимым объёмом используемой памяти. Если мы \textit{случайно} выставим \verb!vm.overcommit_ratio! хотя бы 100, то при переполнении реальной памяти... будет вызван OOM killer.
\end{itemize} 

\begin{center}
slab-алгоритм, baddy-алгоритм.
\end{center}
