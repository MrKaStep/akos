\newpage
\section{ext*, UFS, (NTFS?), FAT}

В этих файловых системах файлы хранятся как набор разрозненных блоков в разных местах

\subsection{FAT (File Allocation Table)}

В файловой системе от начала диска лежат:

\begin{itemize}
\item массив свободных-занятых блоков (File Allocation Table)
\begin{enumerate}
\item Блок свободен
\item Занят файлом
\item Системный --- обычно хранилище swap, системные блоки должны идти подряд
\item bad-block
\end{enumerate}
Также в этом массиве хранится различная метаинформация, например, размер блока. Сама таблица является суперблоком.
\item Копия FAT
\item Первый блок после копии FAT --- корневой каталог файловой системы.
\end{itemize}

Блок файловой системы FAT поделен на две области: данные и, в конце блока, ссылка на следующий блок. Ввиду такой системы в FAT нет нормального индексного дескриптора, а информация о размере файла хранится в каталоге.

Из-за разделения файлов на блоки есть явление фрагментации, которое, к слову, теряет свою негативную сторону при использовании SSD.

Большие файлы хранить невозможно из-за нескольких ограничений:
\begin{itemize}
\item Размер ссылки на следующий блок (ограничение на размер устройства)
\item Размер описания размера файла в каталоге.
\item Размер блока
\end{itemize}

\subsection{Другие файловые системы}

В какой-то момент люди поняли, что FAT ущербен и начали придумывать что-то другое. Была придумана следующая схема:


\begin{itemize}
\item{Суперблок}

\begin{enumerate}
\item размер файловой системы в блоках
\item размер блока (должен быть кратен размеру блока блочного устройства, актуально на всех системах)
\item дата последнего монтирования и место монтирования
\item label --- метка файловой системы (например, на флешках <<KINGSTON 32GB>>)
\item UUID (Universally Unique Identifier) --- уникальный идентификатор экземпляра созданной файловой системы, вероятность совпадения с другим UUID, созданным в мире, крайне мала. Может быть использован вместо label'а для монтирования файловой системы
\item дата последней проверки проверки целостности
\item была ли файловая система размонтирована (если нет, то произошёл сбой, например, отключение питания, перед повторным монтированием обязательна проверка целостности)
\item битовый массив свободных-занятых блоков.
\item число индексных дескрипторов
\end{enumerate}

Всё дисковое пространство делится на группы блоков, в начале каждой из которых лежит суперблок. Такой подход обеспечивает большую <<выживаемость>> данных по сравнению с FAT.

\item{Суперблок группы}

Некоторая часть суперблока, которая записана в каждой группе после суперблока. В основном предназначен для хранения массива свободных-занятых блоков данной группы.

\item{Массив индексных дескрипторов}

Содержит в себе метаинформацию о группе блоков

\end{itemize}

\subsubsection{Немного про индексные дескрипторы}

В индексном дескрипторе, помимо информации, обсуждённой ранее, хранится также и счётчик ссылок. В UNIX-системах на одну область файловой системы может хранится несколько так называемых \textbf{жёстких ссылок}. По сути это имена, которыми называется данный файловый дескриптор, информация об этих именах хранится в файлах каталогов.

В момент удаления файла, счётчик ссылок уменьшается на 1, а при достижении 0 происходит <<лёгкий ад>>

Также в индексном дескрипторе есть такая вещь, как xattr. В нем хранится метаинформация, котрая не предусмотрена базовой системой.

\subsection{Регулярные файлы и каталоги}
Информация в индексном дескрипторе регулярного файла:
\begin{enumerate}
\item Размер в байтах
\item Способ хранения в блоках данных. В UNIX используется массив номеров блоков, которые заняты данным файлом. До тех пор, пока для хранения файла хватает, условно, 10 блоков, то для нумерации используется этот массив напрямую. Иначе следующий блок за этими 10 интерпретируется не как блок данных, а блок с массивом номеров блоков.

Если же и этого не хватает, то следующий блок указывает на массив номеров блоков, которые интерпретируются так же, как и предыдущий блок --- массивы номеров действительных блоков. И таким образом это дерево блоков может разрастаться вплоть до границы массива номеров блоков в индексном дескрипторе. Размеры в блоках так будут составлять  10, 110, 1110, ...
\end{enumerate}

\subsection{А чего бы ещё навернуть?}

\subsubsection{Файловые системы с дырками}

Где-то в суперблоке можно завести специальные блоки, которые часто повторяются в файловой системе (например, блок из одних нулей). При попытке чтения такого блока драйвером файловой системы будут выданы нули без обращения к диску. Если же файловая система достаточно умная, то она может обнаружить, что есть много однотипных блоков, пометить их дырявыми и ссылаться на один и тот же блок.

\subsection{Файл каталога}

Содержимой одной записи файла каталога:

\begin{itemize}
\item offset\_next --- смещение до следующей записи
\item Тип объекта
\item Имя объекта --- имеет фиксированный размер
\item inode
\end{itemize}

Файл каталога состоит из множества таких записей. 

Удаление файла из каталога происходит путём... Изменения offset'а предыдущей записи для <<перескока>> через удаляемый файл. Из-за этого файлы каталогов имеют неприятное свойство со временем расти. 

\subsection{Проверка целостности}

С этой точки зрения существует 3 типа файловых систем:

\begin{enumerate}
\item Без файла журнала
\item С файлом журнала. Этот файл журнала реализует аналог транзакции из области баз данных, в котором хранится информация о текущей операции. После завершения операции файл журнала очищается.

Если же операция не была завершена, то при проверке целостности изменения будут откачены.

\item С разделом журнала.

В более продвинутых системах, например, в больших БД, журнал хранит все изменения файловой системы с возможностью отката до любого предыдущего состояния. По этому принципу работает zfs --- довольно новая система, предназначенная для хранения огромных данных, и, возможно, UFS2. И, конечно же, jfs (journal file system) от IBM. Также существует Razerfs.
\end{enumerate} 

Как же проходит проверка целостности?

\begin{enumerate}
\item При наличии, разбираемся с журналом
\item Суперблок копируется в оперативную память (или <<сумма>> всех суперблоков)
\item Строим в оперативной памяти массив (не битовый) по числу блоков файловой системы и инициализируем нулями
\item Проход по области индексных дескрипторов. Если дескриптор используется, то выставляем в массив блоков 1, иначе оставляем 0

Конфликты могут быть вида:
\begin{itemize}
\item 0 в суперблоке, 1 в массиве (в суперблоке не используется). В этом случае лучше сказать, что на самом деле индексный дескриптор не используется.
\item 1 в суперблоке, 0 в массиве (в суперблоке используется). В этой ситуации нужно пройти по списку каталогов и если он хоть где-то встречается, то нужно его пометить как используемый, иначе грохнуть в суперблоке.
\end{itemize}
\item Проход по индексным дескрипторам, инкрементируя значение в массиве у всех блоков, на которые ссылается данный индексный дескриптор

Конфликты могут быть вида:
\begin{itemize}
\item 0 в суперблоке, 1 в массиве (в суперблоке не используется). В этом случае суперблок помечается 1.
\item 1 в суперблоке, 0 в массиве (в суперблоке используется). Можно просто стереть блок. Но эту операцию нужно делать в последний момент. 

Эта ситуация может может возникнуть в 2-х случаях: в случае повреждения суперблока (тогда всё нормально) и в случае повреждения индексного дескриптора. Тогда должен возникнуть блок или первого, или третьего типа.
\item 1 в супер блоке, >1 в массиве. В этой ситуации делается копия блока и один или оба блока помещаются в lost and found. При наличии таких конфликтов все блоки типа 2 помечаются 1 и помещаются в lost and found.
\end{itemize}
\end{enumerate}






