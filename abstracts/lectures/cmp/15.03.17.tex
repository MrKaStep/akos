\subsubsection{Выравнивание памяти}
При обращении к памяти разным количеством байт могут получаться разные эффекты. При обращении к одному байту, адрес к которому мы обращаемся, не важен. Если же мы обращаемся двумя и большим числом байт, то при несовпадении делимости номера адреса, можно или получить или деградацию производительности или ошибку обращения к памяти.

В $C$ при объявлении

\begin{verbatim}
struct s
{
    char a;
    int b;
}
\end{verbatim}
переменные будут размещены в том порядке, в котором они указаны в структуре. Если размещать четырёхбайтовый \verb!int! сразу после однобайтового \verb!char!'а, то при каждом обращении к \verb!b! нужно будет делать два запроса к памяти. Вероятно, что итоговый размер будет 6 байт. Но можно заставить компилятор (используя определённые опции)

\section{Виртуальная память}

\begin{enumerate}
\item Сегментная организация. При такой организации вся память разбита на некоторые сегменты, у которых хранятся адреса. Адрес делится на \textbf{базу сегмента} и \textbf{смещение внутри сегмента}. Таким образом, перемещения между сегментами делятся на два типа:
\begin{itemize}
\item <<короткие>> переходы --- в адресе изменяется только 32-битное смещение внутри сегмента.
\item <<длинные>> переходы --- меняется также и база сегмента.
\end{itemize}
У этой организации есть применение в защите памяти. Если мы попытаемся выйти за границу сегмента, то случится аппаратная ошибка, которая впоследствие обработана операционной системой, вместо порчи каки-либо данных. Так, к защите памяти относятся
\begin{enumerate}
\item Размер сегмента и база --- предотвращают выход за границу используемой памяти
\item Тип сегмента
\begin{itemize}
\item системный
\item сегмент кода --- можно обращаться только к инструкциям, нельзя обращаться как к данным
\item сегмент данных (возможно, read-only)
\item сегмент стека (в современных --- частный случай сегмента данных). Обычно не подразумевает запись/чтение, используются для стековых операций
\end{itemize}
\item Уровень привелегий. Процессор может находится в одном из уровней привелегий (хранится в регистре флагов). Привилегии как-то ограничивают набор доступных инструкций и адресов. Программа пользователя обычно работает на самом непривелегированном уровне (user-mode). Самым привелегированным является kernel-mode, он работает на 0-ом уровне привилегий.

В архитектуре Intel вся информация о сегментах хранится в таблице сегментов, доступной по регистру \verb!gdtr!.
\end{enumerate}
Глобальные переменные описываются в сегменте данных.
Константы описываются в read-only сегменте данных. В архитектуре Intel они хранятся в сегменте кода.
\end{enumerate}

\subsubsection*{Язык ASSEMBLER}
Этот язык --- способ записи команд в мнемоническом виде. После компиляции этого кода получается файл \verb!.o! с объектным кодом.

Для работы с \verb!.o! есть \verb!binutils!:
\begin{itemize}
\item \verb!nm! --- выводит все символы из объектного файла
\item \verb!ld! --- преобразует набор объектных файлов в исполняемый файл с расширением \verb!.ELF! (Linux), \verb!MZ! (Windows), \verb!.COFF!. Отличия заключаются в способе хранения программы
\item \verb!as! --- принимает файлы \verb!.s! (\verb!.asm!) d файлы \verb!.o!.
\item \verb!objdump! --- по объектному файлу генерирует код assembler, который, в свою очередь, при компиляции даст исходный объектный файл
\item \verb!addr2line! или \verb!addrtoline! --- говорит, к какой строчке объектного файла относится данный адрес
\end{itemize}

В дальнейшем речь будет идти о \verb!gas! (GNU Assembler).

В \verb!gas! всё, что начитается с точки, является так называемой директивой.

\begin{enumerate}
\item Секции
\begin{itemize}
\item \verb!.text! --- инструкции
\item \verb!.data! --- переменные
\item \verb!.rodata! --- read-only data
\item \verb!.bss! --- неинициализированные данные, принудительно заполнено нулями.
\end{itemize}
\item Описания переменных
\begin{itemize}
\item \verb!.byte, ...!. Например, \verb!.byte 'a','b'! задаёт двухбайтовую переменную в которой первый байт соответствует 'a', а второй --- 'b'.
\item \verb!.word! --- 2 байта
\item \verb!.long! (\verb!.int!) --- 4 байта
\item \verb!.quad! --- восемь байт
\item \verb!.double! --- 8 байт, число с плавающей точкой
\item \verb!.ascii! --- строка без ноля (\verb!.ascii "abc"!)
\item \verb!.string! --- нуль-терминированная строка
\item Управление выравниванием. Директива \verb!.align num! гарантирует, что следующий адрес будет кратен num
\item \verb!.space num! --- захватывает num байт. \verb!lcom!, \verb!com! делают то же самое, \verb!lcom! позволяет задать имя.
\end{itemize}
\item Команды
\begin{itemize}
\item При написании чего-либо (адреса или названия переменной) без символа \verb!$! интерпретируется как адрес, если добавить \verb!$!, будет вычислено число. Регистры используются через \verb!%!, например, \verb!%r15!
\begin{verbatim}
movg arr, %rdi;
\end{verbatim}
Записать значение по адресу \verb!arr! в регистр \verb!rdi!
\item Косвенная адресация. В gas задаётся круглыми скобками. Синтаксис \verb!-4(%rdi)! означает интерпретацию содержимого регистра как адреса, применение к этому адресу смещения и получения значения.
\end{itemize}
\item Метки
\begin{itemize}
\item \verb!label: ...! --- метка, на которую линковщик не обратит внимания.

\end{itemize}
\end{enumerate}
