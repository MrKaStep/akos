\begin{verbatim}
ssize_t read(int fd, void* buf, size_t size);
ssize_t write(int fd, void* buf, size_t size);
\end{verbatim}

Эти функции принимают файловый дескриптор, буфер (в/из которого писать/читать) и количество нужных байт. В случае ошибки возвращают -1 и выставляют переменную \verb!errno!. Иначе возвращают количество успешно прочитанных байт.

\subsection{Порождение процессов}

\subsubsection{Создание процессов}

\verb!pid_t fork()! --- породит процесс, возвращает идентификатор этого процесса.

\verb!pid_t getppid()! --- возвращает идентификатор родительского процесса.

\verb!pid_t getpid()! --- возвращает идентификатор самого процесса.

При исполнении \verb!fork! будет создан точно такой же процесс, что и наш, с тем же кодом и скопированными данными и стеком.

\subsubsection{Остановка процессов}

А как можно завершить процесс?

\verb!abort()! --- неприличный способ убицца ап стенку. Процесс аварийно завершается. Если получится, будет создан дамп процесса.

\verb!_exit(int status)! --- системный вызов, завершающий текущий процесс с возвратом \verb!status!.

\verb!exit(int status)! --- помимо завершения процесса, закрывает стандартные потоки ввода, вывода и ошибок.

\subsubsection{Получение информации о процессе}

\verb!pid_t wait(int* status)! --- блокировка процесса до остановки какого-то из дочерних процессов. 

Возвращает идентификатор завершившегося процесса, записывая в \verb!status! то, что было возвращено и немного служебной информации. Если на момент вызова \verb!wait! дочерних процессов не было, то в \verb!status! кладётся \verb!-1! и процесс не блокируется.

\verb!pid_t waitpid(pid_t pid, int mode, int* status)! --- ожидание завершения конкретного процесса. В качестве режима можно указать, например, 
\begin{itemize}
\item \verb!WNOHUNG! --- заставит процесс продолжить работу в случае, если \verb!pid! живой. 
\item \verb!WSTOPED! --- проверка на то, остановлен ли процесс \verb!pid!
\item \ldots
\end{itemize}
Возвращает указанный \verb!pid!, если всё корректно. Если в \verb!pid! указан 0, то мы ждём любой дочерний процесс. Если указывать \verb!-pid!, то будет ожидание группы с идентификатором \verb!pid!.

А что делать с \verb!status!? Для его разбора есть набор макросов:
\begin{itemize}
\item \verb!WIFEXITED(status)! --- вернёт \verb!true! если при завершении процесса был вызван \verb!_exit!, иначе \verb!false!
\item \verb!WIFSIGNALED(status)! --- если процесс был завершён передачей сигнала
\item \verb!WIFSTOPPED(status)! --- если процесс был остановлен
\item \verb!WUNTRACED(status)! --- если процесс не трассируемый, то есть не находится под отладчиком.
\item \verb!WEXITSTATUS(status)! --- то, что было передано в \verb!exit!, обрубленное до того, где не лежит служебная информация.
\end{itemize}

\subsubsection{Замещение тела процесса}

\verb!execve(const char* path_to_file, char** args, char** env)! --- замена тела процесса. Программа, на которую мы будем заменяться --- первый аргумент. \verb!args! --- аргументы запуска этой программы, \verb!env! --- переменные окружения, причём переменные, которые были до этого, \textbf{не сохраняются}.

\verb!execve! --- системный вызов. Всё дальнеёшее --- обёртки над ним, которые выглядят как \verb!exec<suff>!. В качестве суффиксов есть следующие варианты:
\begin{itemize}
\item \verb!e! --- передача переменных окружения
\item \verb!p! --- поиск программа в переменной \verb!PATH!
\item \verb!v! --- передача по \verb!char**!
\item \verb!l! --- передача через \verb!(char* arg0, ...)!
\end{itemize}