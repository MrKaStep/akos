\pagebreak
\section*{Программы на C}

C-программа --- набор файлов с расширениями \verb!.c! и \verb!.h! . Сборка состоит из следующих шагов:
\begin{enumerate}
\item Макроподстановка, замена всех макросов на то, что он собой символизирует.
\item Компиляция в assembler.
\item Преобразование в объектный код.
\item Линковка --- связка отдельных объектных файлов в единую программу.
\end{enumerate} 

.h файлы в результате компиляции должны выдавать пустой объектный код.

\subsection*{Компиляторы}

В мире UNIX принят компилятор \verb!cc! --- то же самое, что и \verb!gcc!. У компиляторов есть различные ключи:
\begin{itemize}
\item \verb!-E! --- остановиться на стадии прекомпиляции и вывести в стандартный поток получившийся код.
\item \verb!-S! --- из файла с расширением \verb!.c! сгенерирует \verb!.s! --- файл с ассемблерным кодом.
\item \verb!-c! --- создание файла \verb!.o! с объектным кодом.
\item \verb!-I каталог! --- поиск подключаемых файлов в каталоге \verb!каталог!. Допустимо множественное использование.
\item \verb!-D! --- создание макропеременной. \verb!-D ENABLE_CUDA!, например.
\item \verb!-L! --- список каталогов для поиска библиотек.
\item \verb!-l<lib_name>! --- подключение библиотеки.
\begin{itemize}
\item Библиотека: файл \verb!lib<name>! с расширением \verb!.a! (статическая библиотека) или \verb!.so! (динамически подключаемая библиотека).
\end{itemize}
\item \verb!-o! --- имя выходного файла.
\item \verb!-g! --- добавляет в объектный файл текст исходного файла
\item \verb!-pg! --- добавление профилировщика.  Перед каждой функцией компилятор добавляет некоторую конструкцию, после считает, сколько раз и сколько времени работала каждая функция.
\item \verb!-O! --- установка уровня оптимизации. \verb!-O0! --- без оптимизации. \verb!-O1! --- чуть-чуть оптимизируем. По ассемблерному коду ещё можно восстановить исходник. \verb!-O2! --- более агрессивно. \verb!-O3! --- очень агрессивная оптимизация. Можно и дальше, но на самом деле --- всё фигня.
\item \verb!-Os! --- оптимизация по размеру. т.е. генерация кода так, чтобы место, занимаемое в оперативной памяти, было минимальным.
\item \verb!-march! --- задаёт конкретную архитектуру, под которую компилируется код. Например, \verb!-march PPC64! --- для Power PC 64.
\item \verb!-mtune! --- выбор конкретного поколения процессора. Можно указать \verb!native!, в этом случае компилятор сам посмотрит в нужный файл и будет делать код под ваш процессор.
\item \verb!--std=<standart_name>! --- стандарт компиляции. \verb!-ansi! --- компиляция в стандарте C89 (ANSI C).
\item \verb!-pedantic! --- <<педантично>> следовать стандарту. Даже компилироваться не будет.
\item \verb!-Wall! --- вывод всех предупреждений.
\item \verb!-Wextra! --- ещё больше предупреждений путём продвинутой диагностики.
\item \verb!-Werror! --- всё, что не нравится компилятору, становится ошибкой.
\end{itemize}

Секции \verb!man!'а.

\begin{enumerate}
\item Программы
\item Системные вызовы
\item Библиотечные функции
\item хз
\item Конфигурационные файлы
\item Xwindow
\item Философская секция
\item Демоны (daemons) и системные утилиты.
\end{enumerate}

\subsection*{С}

Базовые типы:
\begin{itemize}
\item \verb!char!
\item \verb!short!
\item \verb!int!
\item \verb!long int!
\item \verb!long long int!
\item \verb!float!
\item \verb!double!
\item \verb!long double!
\end{itemize}

Модификаторы типов:
\begin{itemize}
\item \verb!unsigned!
\item \verb!const! --- запихнуть переменную в область кода.
\item \verb!static! --- описание не на стеке, а в области данных. Можно обращаться только из этой функции. В глобальной области: только из этого файла.
\item \verb!extern! --- тело переменной находится в другом объектном файле. Найти --- задача линковщика.
\item \verb!auto! --- размещение одтаётся компилятору.
\item \verb!register! --- просьба компилятору \textbf{по возможности} разместить переменную в регистре.
\item \verb!volatile! --- приказывает переменной всегда находится в одной и той же памяти.
\end{itemize}